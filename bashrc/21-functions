# Double-fzf function to login to AWS SSO and then select an EKS cluster
eks-fzf-login() {
  local profile_name cluster_list selected_cluster_info cluster_name region

  # 1. Use your fzf command to select the profile
  profile_name=$(cat ~/.aws/config | grep "\[profile" | sed 's/\[profile \?//g; s/\]//g' | fzf)

  # 2. Exit if user pressed Esc (no profile selected)
  if [[ -z "$profile_name" ]]; then
    echo "No profile selected. Aborting."
    return 1
  fi

  echo "Selected profile: $profile_name"
  echo "Attempting AWS SSO login..."

  # 3. Log in using AWS SSO
  if ! aws sso login --profile "$profile_name"; then
    echo "AWS SSO login failed. Aborting."
    return 1
  fi

  echo "SSO login successful."
  echo "Fetching EKS clusters from ap-southeast-1 and ap-southeast-3..."

  # 4. Helper function to find clusters in specific regions
  _get_all_clusters() {
    local target_regions="ap-southeast-1 ap-southeast-3"

    # Header line for fzf
    echo "Cluster Name,Region"

    for r in $target_regions; do
      echo "Checking region: $r..." >&2
      local clusters_in_region=$(aws eks list-clusters --profile "$profile_name" --region "$r" --query "clusters[]" --output text 2>/dev/null)

      for c in $clusters_in_region; do
        echo "$c,$r"
      done
    done
  }

  # 5. Run the helper and pipe the list into fzf
  cluster_list=$(_get_all_clusters)

  if [[ $(echo "$cluster_list" | wc -l) -le 1 ]]; then
    echo "No EKS clusters found for profile '$profile_name' in ap-southeast-1 or ap-southeast-3."
    return 1
  fi

  # 6. Run fzf to select the cluster
  # --- MODIFIED PREVIEW COMMAND ---
  selected_cluster_info=$(echo "$cluster_list" | \
    fzf --header-lines=1 \
        --preview="
          # Get vars from fzf's input line
          cluster_info={}
          cluster_name=\$(echo \$cluster_info | cut -d',' -f1)
          region_name=\$(echo \$cluster_info | cut -d',' -f2)

          # 1. Show status (this part is fast)
          aws eks describe-cluster --profile $profile_name --name \$cluster_name --region \$region_name --query cluster.status 2>/dev/null

          echo '---'
          echo 'Namespaces (loading...):'

          # 2. Get namespaces (this part is slow)
          # Create a unique, temporary kubeconfig file
          TMP_KUBECONFIG=\$(mktemp)

          # Ensure the temp file is cleaned up when the preview command exits
          trap \"rm -f \$TMP_KUBECONFIG\" EXIT

          # Generate the temp config, hiding all 'Updated context...' messages
          if aws eks update-kubeconfig --profile $profile_name --name \$cluster_name --region \$region_name --kubeconfig \$TMP_KUBECONFIG &>/dev/null; then
            # If successful, list namespaces
            kubectl --kubeconfig \$TMP_KUBECONFIG get ns --no-headers -o custom-columns=NAME:.metadata.name
          else
            echo 'Failed to generate temp kubeconfig.'
          fi
        ")

  # 7. Exit if user pressed Esc (no cluster selected)
  if [[ -z "$selected_cluster_info" ]]; then
    echo "No cluster selected. Aborting."
    return 1
  fi

  # 8. Parse the "Cluster,Region" string
  cluster_name=$(echo "$selected_cluster_info" | cut -d',' -f1)
  region=$(echo "$selected_cluster_info" | cut -d',' -f2)

  echo "Updating kubeconfig for cluster '$cluster_name' in region '$region'..."

  # 9. Update kubeconfig
  if aws eks update-kubeconfig --name "$cluster_name" --region "$region" --profile "$profile_name"; then
    echo "Kubeconfig updated successfully!"
    echo "You can now use: kubectl get nodes"
  else
    echo "Failed to update kubeconfig."
    return 1
  fi
}
