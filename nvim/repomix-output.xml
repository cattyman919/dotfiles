This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
after/
  ftplugin/
    markdown.lua
    python.lua
    typescriptreact.lua
ftplugin/
  java.lua
lua/
  config/
    core/
      autocmds.lua
      keymaps.lua
      options.lua
  plugins/
    arrow.lua
    autopairs.lua
    colorizer.lua
    completion.lua
    copilot.lua
    diagnostics.lua
    discord.lua
    filetree.lua
    flash.lua
    format.lua
    image-support.lua
    indent.lua
    init.lua
    lsp.lua
    lualine.lua
    mini.lua
    namu.lua
    neoscroll.lua
    render-markdown.lua
    snacks.lua
    telescope.lua
    theme.lua
    treesitter.lua
    trouble.lua
    undotree.lua
    vim.maximizer.lua
  snippets/
    go.lua
    rust.lua
  lazy_setup.lua
init.lua
lazy-lock.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="after/ftplugin/markdown.lua">
local set = vim.opt_local

-- set.textwidth = 120 -- Wrap text at 80 characters
set.spell = true -- Enable spell checking
set.linebreak = true
set.number = false
set.relativenumber = false

-- added extra highlights for markdown files to render highlights properly
-- thx to Linkarzu

local color1_bg = "#ff757f"
local color2_bg = "#4fd6be"
local color3_bg = "#7dcfff"
local color4_bg = "#ff9e64"
local color5_bg = "#7aa2f7"
local color6_bg = "#c0caf5"
local color_fg = "#1F2335"

vim.cmd(
	string.format([[highlight @markup.heading.1.markdown cterm=bold gui=bold guifg=%s guibg=%s]], color_fg, color1_bg)
)
vim.cmd(
	string.format([[highlight @markup.heading.2.markdown cterm=bold gui=bold guifg=%s guibg=%s]], color_fg, color2_bg)
)
vim.cmd(
	string.format([[highlight @markup.heading.3.markdown cterm=bold gui=bold guifg=%s guibg=%s]], color_fg, color3_bg)
)
vim.cmd(
	string.format([[highlight @markup.heading.4.markdown cterm=bold gui=bold guifg=%s guibg=%s]], color_fg, color4_bg)
)
vim.cmd(
	string.format([[highlight @markup.heading.5.markdown cterm=bold gui=bold guifg=%s guibg=%s]], color_fg, color5_bg)
)
vim.cmd(
	string.format([[highlight @markup.heading.6.markdown cterm=bold gui=bold guifg=%s guibg=%s]], color_fg, color6_bg)
)
</file>

<file path="after/ftplugin/python.lua">
local set = vim.opt_local

set.tabstop = 4
set.shiftwidth = 4
set.softtabstop = 4
set.expandtab = true
</file>

<file path="after/ftplugin/typescriptreact.lua">
local set = vim.opt_local

set.tabstop = 2
set.shiftwidth = 2
set.softtabstop = 2
set.expandtab = true
</file>

<file path="ftplugin/java.lua">
local home = os.getenv("HOME")
local workspace_path = home .. "/.local/share/nvim/jdtls-workspace/"
local project_name = vim.fn.fnamemodify(vim.fn.getcwd(), ":p:h:t")
local workspace_dir = workspace_path .. project_name

local status, jdtls = pcall(require, "jdtls")
if not status then
	return
end
local extendedClientCapabilities = jdtls.extendedClientCapabilities

local config = {
	cmd = {
		"java",
		"-Declipse.application=org.eclipse.jdt.ls.core.id1",
		"-Dosgi.bundles.defaultStartLevel=4",
		"-Declipse.product=org.eclipse.jdt.ls.core.product",
		"-Dlog.protocol=true",
		"-Dlog.level=ALL",
		"-Xmx1g",
		"--add-modules=ALL-SYSTEM",
		"--add-opens",
		"java.base/java.util=ALL-UNNAMED",
		"--add-opens",
		"java.base/java.lang=ALL-UNNAMED",
		"-javaagent:" .. home .. "/.local/share/nvim/mason/packages/jdtls/lombok.jar",
		"-jar",
		vim.fn.glob(home .. "/.local/share/nvim/mason/packages/jdtls/plugins/org.eclipse.equinox.launcher_*.jar"),
		"-configuration",
		home .. "/.local/share/nvim/mason/packages/jdtls/config_linux",
		"-data",
		workspace_dir,
	},
	root_dir = require("jdtls.setup").find_root({ ".git", "mvnw", "gradlew", "pom.xml", "build.gradle" }),

	settings = {
		java = {
			signatureHelp = { enabled = true },
			extendedClientCapabilities = extendedClientCapabilities,
			maven = {
				downloadSources = true,
			},
			referencesCodeLens = {
				enabled = true,
			},
			references = {
				includeDecompiledSources = true,
			},
			inlayHints = {
				parameterNames = {
					enabled = "all", -- literals, all, none
				},
			},
			format = {
				enabled = false,
			},
		},
	},

	init_options = {
		bundles = {},
	},
}
require("jdtls").start_or_attach(config)

vim.keymap.set("n", "<leader>co", "<Cmd>lua require'jdtls'.organize_imports()<CR>", { desc = "Organize Imports" })
vim.keymap.set("n", "<leader>crv", "<Cmd>lua require('jdtls').extract_variable()<CR>", { desc = "Extract Variable" })
vim.keymap.set(
	"v",
	"<leader>crv",
	"<Esc><Cmd>lua require('jdtls').extract_variable(true)<CR>",
	{ desc = "Extract Variable" }
)
vim.keymap.set("n", "<leader>crc", "<Cmd>lua require('jdtls').extract_constant()<CR>", { desc = "Extract Constant" })
vim.keymap.set(
	"v",
	"<leader>crc",
	"<Esc><Cmd>lua require('jdtls').extract_constant(true)<CR>",
	{ desc = "Extract Constant" }
)
vim.keymap.set(
	"v",
	"<leader>crm",
	"<Esc><Cmd>lua require('jdtls').extract_method(true)<CR>",
	{ desc = "Extract Method" }
)
</file>

<file path="lua/config/core/autocmds.lua">
-- AutoCommands

-- See `:help vim_highlight.on_yank()`
vim.api.nvim_create_autocmd("TextYankPost", {
	desc = "Highlight when yanking (copying) text",
	group = vim.api.nvim_create_augroup("kickstart-highlight-yank", { clear = true }),
	callback = function()
		vim.highlight.on_yank()
	end,
})

vim.api.nvim_create_autocmd("TermOpen", {
	group = vim.api.nvim_create_augroup("custom-term-open", { clear = true }),
	callback = function()
		vim.opt.number = false
		vim.opt.relativenumber = false
	end,
})

vim.api.nvim_create_autocmd({
	"WinScrolled", -- or WinResized on NVIM-v0.9 and higher
	"BufWinEnter",
	"CursorHold",
	"InsertLeave",

	-- include this if you have set `show_modified` to `true`
	"BufModifiedSet",
}, {
	group = vim.api.nvim_create_augroup("barbecue.updater", {}),
	callback = function()
		require("barbecue.ui").update()
	end,
})

vim.api.nvim_create_augroup("BashSheBang", { clear = true })
vim.api.nvim_create_autocmd({ "BufRead", "BufNewFile" }, {
	group = "BashSheBang",
	callback = function(args)
		local lines = vim.api.nvim_buf_get_lines(args.buf, 0, 1, false) or ""

		if #lines > 0 then
			local first_line = lines[1]
			if string.match(first_line, "^#!.*[ /]bash") or string.match(first_line, "^#!.*[ /]sh") then
				vim.bo[args.buf].filetype = "sh"
			end
		end
	end,
})
</file>

<file path="lua/config/core/keymaps.lua">
-- Keymaps
local opts = { noremap = true, silent = true }

-- Toggle relative Number
vim.keymap.set("n", "<leader>rn", function()
	vim.wo.relativenumber = not vim.wo.relativenumber
end, { desc = "Toggle relative numbers" })

vim.keymap.set("n", "<space><space>x", "<cmd>source %<CR>") -- Source File
vim.keymap.set("n", "<C-s>", ":write<CR>") -- Save file with CTRL + S
vim.keymap.set("n", "<C-c>", ":%y<CR>", opts) -- Copy all lines in buffer

-- Move left/right in insert mode with CTRL+H/L
-- vim.keymap.set("i", "<C-h>", "<Left>", { noremap = true, silent = true })
-- vim.keymap.set("i", "<C-l>", "<Right>", { noremap = true, silent = true })

-- Moves Lines
vim.keymap.set("v", "J", ":m '>+1<CR>gv=gv", { desc = "moves lines down in visual selection" })
vim.keymap.set("v", "K", ":m '<-2<CR>gv=gv", { desc = "moves lines up in visual selection" })

-- Navigations
vim.keymap.set("n", "<C-d>", "<C-d>zz", { desc = "move down in buffer with cursor centered" })
vim.keymap.set("n", "<C-u>", "<C-u>zz", { desc = "move up in buffer with cursor centered" })

vim.keymap.set("n", "n", "nzzzv") -- Center Cursor when navigating with n
vim.keymap.set("n", "N", "Nzzzv")

-- ctrl c as escape cuz Im lazy to reach up to the esc key
vim.keymap.set("i", "<C-c>", "<Esc>")
vim.keymap.set("n", "<Esc>", ":nohl<CR>", { desc = "Clear search hl", silent = true })

-- prevent x delete from registering when next paste
vim.keymap.set("n", "x", '"_x', opts)

-- Diagnostics

-- Toggle LSP diagnostics visibility
-- local isLspDiagnosticsVisible = true
-- vim.keymap.set("n", "<C-x>", function()
-- 	isLspDiagnosticsVisible = not isLspDiagnosticsVisible
-- 	vim.diagnostic.config({
-- 		virtual_text = isLspDiagnosticsVisible,
-- 		underline = isLspDiagnosticsVisible,
-- 	})
-- end, { desc = "Toggle LSP diagnostics" })

vim.keymap.set("n", "<leader>dl", vim.diagnostic.setloclist, { desc = "Open diagnostics list (location)" })
vim.keymap.set("n", "<leader>dq", vim.diagnostic.setqflist, { desc = "Open diagnostics list (quickfix)" })

-- LSP
vim.keymap.set("n", "gd", vim.lsp.buf.definition, { desc = "LSP Go To Definition" })
vim.keymap.set("n", "gr", vim.lsp.buf.references, { desc = "LSP Go To References" })
vim.keymap.set("v", "<space>ga", vim.lsp.buf.code_action, { desc = "LSP Code Action (Range)" })
vim.keymap.set("n", "<space>ih", function()
	vim.lsp.inlay_hint.enable(not vim.lsp.inlay_hint.is_enabled())
end, { desc = "Toggal inlay hints" })

-- Unlink/Exit the current snippet (stops <Tab> from jumping)
vim.keymap.set({ "i", "s" }, "<C-c>", function()
	if require("luasnip").in_snippet() then
		require("luasnip").unlink_current()
	end
	return "<Esc>" -- Still perform the normal Escape behavior
end, { expr = true, desc = "Exit snippet and insert mode" })

-- Namu
vim.keymap.set("n", "<leader>ss", ":Namu symbols<cr>", {
	desc = "Jump to LSP symbol",
	silent = true,
})
vim.keymap.set("n", "<leader>sw", ":Namu workspace<cr>", {
	desc = "LSP Symbols - Workspace",
	silent = true,
})

-- Snacks
vim.keymap.set("n", "<space>en", function()
	require("snacks").picker.files({ cwd = vim.fn.stdpath("config") })
end)
vim.keymap.set("n", "grr", require("snacks").picker.lsp_references, { desc = "Find LSP References" })
vim.keymap.set("n", "gi", require("snacks").picker.lsp_implementations, { desc = "Find LSP References" })
vim.keymap.set("n", "<space>ff", require("snacks").picker.files, { desc = "Find files" })
vim.keymap.set("n", "<space>fs", require("snacks").picker.smart, { desc = "Smart Find files" })
vim.keymap.set("n", "<space>fo", require("snacks").picker.recent, { desc = "Find Recent files" })
vim.keymap.set("n", "<space>fg", require("snacks").picker.git_files, { desc = "Find Git files" })
vim.keymap.set("n", "<space>sb", require("snacks").picker.lines, { desc = "Buffer Lines" })
vim.keymap.set("n", "<space>fw", require("snacks").picker.grep, { desc = "Grep" })
vim.keymap.set("n", "<space>km", require("snacks").picker.keymaps, { desc = "Keymaps" })
vim.keymap.set("n", "<space>lg", function()
	require("snacks").lazygit()
end, { desc = "Lazygit" })

-- -- Grep
-- { "<leader>sB", function() Snacks.picker.grep_buffers() end, desc = "Grep Open Buffers" },
-- { "<leader>sg", function() Snacks.picker.grep() end, desc = "Grep" },
-- { "<leader>sw", function() Snacks.picker.grep_word() end, desc = "Visual selection or word", mode = { "n", "x" }
</file>

<file path="lua/config/core/options.lua">
-- Configs
vim.opt.shiftwidth = 2 -- Or your preferred number of spaces
vim.opt.tabstop = 2 -- It's also common to set tabstop to the same value
vim.opt.expandtab = true -- Ensure tabs are converted to spaces
vim.opt.clipboard = "unnamedplus" -- Allow system clipboards
vim.opt.number = true
vim.opt.relativenumber = true
vim.opt.cursorline = true
vim.opt.helpheight = 0
vim.opt.laststatus = 3
vim.opt.updatetime = 200

-- disable netrw at the very start of your init.lua
vim.g.loaded_netrw = 1
vim.g.loaded_netrwPlugin = 1

-- optionally enable 24-bit colour
vim.opt.termguicolors = true

-- Diagnostics
vim.diagnostic.config({
	-- Show signs in the gutter
	signs = {
		active = true,
	}, -- or a table to customize (see below)

	-- Show virtual text (inline messages)
	virtual_text = false, -- or a table to customize (see below)

	-- Underline the diagnostic'd text
	underline = true,

	-- Update diagnostics in insert mode (can be distracting for some)
	update_in_insert = false,

	-- Sort diagnostics by severity
	severity_sort = true,

	-- Configure the floating window for diagnostics (e.g., when using vim.diagnostic.open_float())
	float = {
		focusable = false, -- Whether the float window can receive focus
		style = "minimal", -- "minimal" or "border" (deprecated in favor of border option)
		border = "rounded", -- "none", "single", "double", "rounded", "solid", "shadow"
		source = "always", -- "always", "if_many" (show source only if multiple sources) or false
		header = "", -- Text to put at the top of the float
		prefix = "", -- Text to put before each diagnostic in the float
		-- scope = "cursor", -- "cursor", "line", "buffer" (for vim.diagnostic.open_float)
	},
})
</file>

<file path="lua/plugins/arrow.lua">
return {
	"otavioschwanck/arrow.nvim",
	dependencies = {
		{ "nvim-tree/nvim-web-devicons" },
		-- or if using `mini.icons`
		-- { "echasnovski/mini.icons" },
	},
	opts = {
		show_icons = true,
		always_show_path = true,
		leader_key = ";", -- Recommended to be a single key
		buffer_leader_key = "m", -- Per Buffer Mappings
	},
}
</file>

<file path="lua/plugins/autopairs.lua">
return {
  {
    "windwp/nvim-autopairs",
    event = "InsertEnter",
    dependencies = {
      "saghen/blink.cmp",
    },
    config = true,
    -- use opts = {} for passing setup options
    -- this is equivalent to setup({}) function
  },
}
</file>

<file path="lua/plugins/colorizer.lua">
return {
	{
		"norcalli/nvim-colorizer.lua",
		config = function()
			require("colorizer").setup()
		end,
	},
}
</file>

<file path="lua/plugins/completion.lua">
return {
	{
		"L3MON4D3/LuaSnip",
		build = "make install_jsregexp",
		config = function()
			require("luasnip.loaders.from_vscode").lazy_load()

			require("luasnip.loaders.from_lua").load({ paths = vim.fn.stdpath("config") .. "/lua/snippets" })

			require("luasnip").filetype_extend("typescript", { "html" })
			require("luasnip").filetype_extend("javascript", { "html" })

			require("luasnip").filetype_extend("typescriptreact", { "html", "typescript" })
			require("luasnip").filetype_extend("javascriptreact", { "html", "javascript" })

			require("luasnip").filetype_extend("astro", { "html", "javascript", "typescript", "tailwindcss" })
		end,
	},

	{
		"saghen/blink.cmp",
		-- optional: provides snippets for the snippet source
		dependencies = {
			-- "Kaiser-Yang/blink-cmp-avante",
			"giuxtaposition/blink-cmp-copilot",
			"rafamadriz/friendly-snippets",
			"L3MON4D3/LuaSnip",
			"nvim-tree/nvim-web-devicons",
			"onsails/lspkind.nvim",
		},

		version = "1.*",

		---@module 'blink.cmp'
		---@type blink.cmp.Config
		opts = {

			keymap = {
				preset = "none",
				["<Tab>"] = { "snippet_forward", "fallback" },
				["<S-Tab>"] = { "snippet_backward", "fallback" },

				["<M-space>"] = { "show", "show_documentation", "hide_documentation" },
				["<M-e>"] = { "hide" },
				["<C-e>"] = { "hide" },
				["<C-l>"] = { "select_and_accept" },
				["<M-l>"] = { "select_and_accept" },
				["<M-j>"] = { "select_next", "fallback_to_mappings" },
				["<M-k>"] = { "select_prev", "fallback_to_mappings" },
				["<C-n>"] = { "select_next", "fallback_to_mappings" },
				["<C-p>"] = { "select_prev", "fallback_to_mappings" },
				["<C-k>"] = { "show_signature", "hide_signature", "fallback" },
				["<C-b>"] = { "scroll_documentation_up", "fallback" },
				["<C-f>"] = { "scroll_documentation_down", "fallback" },
			},

			appearance = {
				nerd_font_variant = "mono",
			},

			-- (Default) Only show the documentation popup when manually triggered
			completion = { -- Define 'completion' as a key
				ghost_text = {
					enabled = true,
					-- show_with_menu = false,
					-- show_without_menu = true,
				},
				trigger = {
					show_on_keyword = true,
				},

				documentation = {
					auto_show = true,
					-- Delay before showing the documentation window
					auto_show_delay_ms = 1000,
					-- Delay before updating the documentation window when selecting a new item,
					-- while an existing item is still visible
					update_delay_ms = 50,
				},
				menu = {
					auto_show = true,
					draw = {
						columns = { { "label", "label_description", gap = 1 }, { "kind_icon", "kind" } }, -- 'columns' is a key in 'draw'
						components = {
							kind_icon = {
								text = function(ctx)
									local icon = ctx.kind_icon
									if vim.tbl_contains({ "Path" }, ctx.source_name) then
										local dev_icon, _ = require("nvim-web-devicons").get_icon(ctx.label)
										if dev_icon then
											icon = dev_icon
										end
									else
										icon = require("lspkind").symbolic(ctx.kind, {
											mode = "symbol",
										})
									end

									return icon .. ctx.icon_gap
								end,

								-- Optionally, use the highlight groups from nvim-web-devicons
								-- You can also add the same function for `kind.highlight` if you want to
								-- keep the highlight groups in sync with the icons.
								highlight = function(ctx)
									local hl = ctx.kind_hl
									if vim.tbl_contains({ "Path" }, ctx.source_name) then
										local dev_icon, dev_hl = require("nvim-web-devicons").get_icon(ctx.label)
										if dev_icon then
											hl = dev_hl
										end
									end
									return hl
								end,
							},
						},
					},
				},
			},
			signature = {
				enabled = true,
			},
			sources = {
				-- default = { "copilot", "lsp", "snippets", "buffer", "path" },
				default = { "lsp", "snippets", "buffer", "path" },
				providers = {
					-- copilot = {
					-- 	name = "copilot",
					-- 	module = "blink-cmp-copilot",
					-- 	score_offset = 100,
					-- 	async = true,
					-- 	transform_items = function(_, items)
					-- 		local CompletionItemKind = require("blink.cmp.types").CompletionItemKind
					-- 		local kind_idx = #CompletionItemKind + 1
					-- 		CompletionItemKind[kind_idx] = "Copilot"
					-- 		for _, item in ipairs(items) do
					-- 			item.kind = kind_idx
					-- 		end
					-- 		return items
					-- 	end,
					-- },
					-- 	avante = {
					-- 		module = "blink-cmp-avante",
					-- 		name = "Avante",
					-- 		opts = {
					-- 			-- options for blink-cmp-avante
					-- 		},
					-- 	},
				},
			},
			snippets = { preset = "luasnip" },
			fuzzy = { implementation = "prefer_rust_with_warning" },
		},
		opts_extend = { "sources.default" },
	},
}
</file>

<file path="lua/plugins/copilot.lua">
return {
	{
		"zbirenbaum/copilot.lua",
		enabled = false,
		cmd = "Copilot",
		event = "InsertEnter",
		opts = {
			-- Disable the default UI from copilot.lua
			-- We want blink.cmp to handle the display
			panel = { enabled = false },
			suggestion = { enabled = false },
		},
	},
}
</file>

<file path="lua/plugins/diagnostics.lua">
return {
	"rachartier/tiny-inline-diagnostic.nvim",
	event = "VeryLazy", -- Or `LspAttach`
	priority = 1000, -- needs to be loaded in first
	config = function()
		require("tiny-inline-diagnostic").setup({
			-- Style preset for diagnostic messages
			-- Available options:
			-- "modern", "classic", "minimal", "powerline",
			-- "ghost", "simple", "nonerdfont", "amongus"
			preset = "classicc",
		})
		vim.diagnostic.config({ virtual_text = false }) -- Only if needed in your configuration, if you already have native LSP diagnostics
	end,
}
</file>

<file path="lua/plugins/discord.lua">
return {
	"vyfor/cord.nvim",
	build = ":Cord update",
	opts = {
		editor = {
			tooltip = "Banger Editor",
		},
		display = {
			theme = "atom",
			flavor = "accent",
			swap_icons = false,
		},
		idle = {
			details = function(opts)
				return string.format("Taking a break from %s", opts.filename)
			end,
		},
		advanced = {
			discord = {
				reconnect = {
					enabled = true,
				},
				pipe_paths = {
					(os.getenv("XDG_RUNTIME_DIR") or "/run/user/1000") .. "/app/com.discordapp.Discord/discord-ipc-0",
				},
			},
		},
	},
}
</file>

<file path="lua/plugins/filetree.lua">
return {
	"nvim-tree/nvim-tree.lua",
	cmd = { "NvimTreeToggle", "NvimTreeFocus" },
	config = function(_, opts)
		require("nvim-tree").setup(opts)
		local api = require("nvim-tree.api")
		vim.keymap.set("n", "<C-n>", api.tree.toggle, { desc = "" })
	end,
	opts = {
		filters = { dotfiles = false },
		disable_netrw = true,
		hijack_cursor = true,
		sync_root_with_cwd = true,
		update_focused_file = {
			enable = true,
			update_root = false,
		},
		view = {
			side = "left",
			width = {
				min = 30,
				max = -1,
			},
			preserve_window_proportions = true,
		},
		diagnostics = {
			enable = true,
		},
		renderer = {
			root_folder_label = false,
			hidden_display = "all",
			-- highlight_git = "icon",
			-- highlight_modified = "icon",
			-- highlight_diagnostics = "icon",
			indent_markers = { enable = true },
			icons = {
				glyphs = {
					default = "󰈚",
					folder = {
						default = "",
						empty = "",
						empty_open = "",
						open = "",
						symlink = "",
					},
					git = { unmerged = "" },
				},
			},
		},
		-- modified = {
		-- 	enable = true,
		-- 	show_on_dirs = true,
		-- 	show_on_open_dirs = true,
		-- },
		actions = {
			open_file = {
				quit_on_open = true,
			},
		},
	},
}
</file>

<file path="lua/plugins/flash.lua">
return {
	"folke/flash.nvim",
	event = "VeryLazy",
	---@type Flash.Config
	opts = {},
	keys = {
		{
			"s",
			mode = { "n", "x", "o" },
			function()
				require("flash").jump()
			end,
			desc = "Flash",
		},
		{
			"S",
			mode = { "n", "x", "o" },
			function()
				require("flash").treesitter()
			end,
			desc = "Flash Treesitter",
		},
		{
			"r",
			mode = "o",
			function()
				require("flash").remote()
			end,
			desc = "Remote Flash",
		},
		{
			"R",
			mode = { "o", "x" },
			function()
				require("flash").treesitter_search()
			end,
			desc = "Treesitter Search",
		},
		{
			"<c-s>",
			mode = { "c" },
			function()
				require("flash").toggle()
			end,
			desc = "Toggle Flash Search",
		},
	},
}
</file>

<file path="lua/plugins/format.lua">
return {
	-- In your lazy.nvim setup (e.g., lua/plugins/format.lua or similar)
	{
		"stevearc/conform.nvim",
		event = { "BufReadPre", "BufNewFile" }, -- Load early enough for format-on-save
		-- cmd = { "ConformInfo" }, -- You can use this if you prefer loading on command
		opts = {
			notify_on_error = true,
			-- Configure format on save
			format_on_save = {
				timeout_ms = 200, -- Set a timeout for format on save
				lsp_fallback = true, -- Fallback to LSP formatting if conform.nvim doesn't have a formatter or fails
				-- If true, conform will try LSP formatting if its own formatters fail or aren't set up for the buffer.
				-- If you only want conform.nvim's defined formatters, set this to false.
			},

			formatters = {
				["slint-lsp"] = {
					cmd = "slint-lsp format /dev/stdin", -- The command to run
					stdin = true, -- It reads from stdin
				},
				rustfmt = {
					cmd = "rustfmt",
					-- args = {
					-- 	"+nightly",
					-- },
					stdin = true, -- rustfmt can read from stdin
				},
				odinfmt = {
					-- Change where to find the command if it isn't in your path.
					command = "odinfmt",
					args = { "-stdin" },
					stdin = true,
				},
				zigfmt = {
					command = "zig",
					args = { "fmt", "--stdin" },
					stdin = true,
				},
			},
			-- Define your formatters by filetype
			formatters_by_ft = {
				lua = { "stylua" },
				python = { "ruff_format", "black" }, -- Tries ruff_format first, then black
				javascript = { "biome", "prettier" }, -- prettierd is faster if available
				typescript = { "biome", "prettier" },
				javascriptreact = { "biome", "prettier" },
				typescriptreact = { "biome", "prettier" },
				json = { "prettierd", "prettier" },
				yaml = { "prettierd", "prettier" },
				markdown = { "prettierd", "prettier" },
				html = { "prettierd", "prettier" },
				css = { "prettierd", "prettier" },
				scss = { "prettierd", "prettier" },
				astro = { "prettier" },
				sh = { "shfmt" },
				go = { "gofmt", "goimports" },
				php = { "pint" },
				cpp = { "clang-format" },
				java = { "google-java-format" },
				rust = { "rustfmt" },
				odin = { "odinfmt" },
				zig = { "zigfmt" },
				-- slint = { "slint-lsp" }, -- Custom formatter for Slint

				-- Example of using a formatter that isn't a default
				-- zig = { "zigfmt" },

				-- You can also define a global fallback or a formatter for any filetype
				["_"] = { "trim_newlines", "trim_whitespace" }, -- Applies to all filetypes if no specific formatter is found / runs after specific ones
			},

			-- You can define custom formatters if needed
			-- formatters = {
			--   my_custom_formatter = {
			--     cmd = "my_formatter_executable",
			--     args = { "--stdin" },
			--     stdin = true, -- Indicates the formatter reads from stdin
			--   }
			-- }
		},
		-- You can also put keymaps in init if you want them defined even earlier
		init = function()
			-- Set a keymap for manual formatting
			vim.keymap.set({ "n", "v" }, "<leader>fm", function() -- "fm" for "manual format"
				require("conform").format({ async = true, lsp_fallback = true, timeout_ms = 200 })
				print("Formatted with conform.nvim")
			end, { desc = "Format buffer with conform.nvim" })
		end,
	},
}
</file>

<file path="lua/plugins/image-support.lua">
return {
  -- requires pngpaste ( brew install pngpaste )
  "HakonHarnes/img-clip.nvim",
  event = "VeryLazy",
  keys = {
    -- suggested keymap
    { "<leader>pi", "<cmd>PasteImage<cr>", desc = "Paste image from system clipboard" },
  },
  opts = {
    default = {
      insert_mode_after_paste = true,
      url_encode_path = true,
      template = "$FILE_PATH",
      use_cursor_in_template = true,

      prompt_for_file_name = true,
      show_dir_path_in_prompt = true,

      use_absolute_path = false,
      relative_to_current_file = true,

      embed_image_as_base64 = false,
      max_base64_size = 10,

      dir_path = function()
        local cwd = vim.fn.getcwd()
        local vault_name = "sethVault" -- obsidian vault dir
        local vault_images_path = "Archives/All-Vault-Images/"

        if cwd:match(vault_name) then
          return vault_images_path
        else
          return "assets"
        end
      end,

      drag_and_drop = {
        enabled = true,
        insert_mode = true,
        copy_images = true,
        download_images = true,
      },
    },
    -- add options here
    -- or leave it empty to use the default settings
  },
}
</file>

<file path="lua/plugins/indent.lua">
return {
	"lukas-reineke/indent-blankline.nvim",
	main = "ibl",
	---@module "ibl"
	---@type ibl.config
	opts = {
		indent = {
			-- char = "┆",
		},
		scope = {
			-- show_start = false,
		},
	},
}
</file>

<file path="lua/plugins/init.lua">
return {
	{
		"folke/which-key.nvim",
		event = "VeryLazy",
		opts = {
			-- your configuration comes here
			-- or leave it empty to use the default settings
			-- refer to the configuration section below
		},
		keys = {
			{
				"<leader>?",
				function()
					require("which-key").show({ global = false })
				end,
				desc = "Buffer Local Keymaps (which-key)",
			},
		},
	},
	{
		-- Notification System
		"j-hui/fidget.nvim",
		opts = {
			-- options
		},
	},
	{
		"elkowar/yuck.vim",
	},
}
</file>

<file path="lua/plugins/lsp.lua">
return {
	{
		"neovim/nvim-lspconfig",
		dependencies = {
			"saghen/blink.cmp",
			{
				"folke/lazydev.nvim",
				ft = "lua", -- only load on lua files
				opts = {
					library = {
						-- See the configuration section for more details
						-- Load luvit types when the `vim.uv` word is found
						{ path = "${3rd}/luv/library", words = { "vim%.uv" } },
					},
				},
			},
			{
				"utilyre/barbecue.nvim",
				name = "barbecue",
				version = "*",
				dependencies = {
					"SmiteshP/nvim-navic",
					"nvim-tree/nvim-web-devicons",
				},
				opts = {
					show_dirname = false,
					create_autocmd = false, -- prevent barbecue from updating itself automatically
				},
			},
		},
		opts = {
			servers = {
				lua_ls = {},
				basedpyright = {},
				bashls = {},
				slint_lsp = {},
				ts_ls = {},
				qmlls = {},
				cssls = {},
				ols = {},
				zls = {},
				neocmake = {},
				angularls = {},
				tailwindcss = {},
				terraformls = {},
				buf_ls = {},
				clangd = {
					cmd = { "clangd", "--background-index", "--log=verbose", "--clang-tidy", "--inlay-hints=true" },
					filetypes = { "c", "cpp", "objc", "objcpp", "cuda" },
				},
				yamlls = {},
				-- sqlls = {},
				sqls = {},
				astro = {},
				dockerls = {},
				-- jdtls = {},
				gopls = {
					settings = {
						gopls = {
							-- enable all types of inlay hints for gopls
							hints = {
								assignVariableTypes = true,
								compositeLiteralTypes = true,
								constantValues = true,
								functionTypeParameters = true,
								parameterNames = true,
								rangeVariableTypes = true,
							},
						},
					},
				},
				-- bacon_ls = {
				-- 	-- Bacon export filename (default: .bacon-locations).
				-- 	locationsFile = ".bacon-locations",
				-- 	-- Try to update diagnostics every time the file is saved (default: true).
				-- 	updateOnSave = true,
				-- 	--  How many milliseconds to wait before updating diagnostics after a save (default: 1000).
				-- 	updateOnSaveWaitMillis = 350,
				-- 	-- Try to update diagnostics every time the file changes (default: true).
				-- 	updateOnChange = true,
				-- 	-- Try to validate that bacon preferences are setup correctly to work with bacon-ls (default: true).
				-- 	validateBaconPreferences = true,
				-- 	-- f no bacon preferences file is found, create a new preferences file with the bacon-ls job definition (default: true).
				-- 	createBaconPreferencesFile = true,
				-- 	-- Run bacon in background for the bacon-ls job (default: true)
				-- 	runBaconInBackground = true,
				-- 	-- Command line arguments to pass to bacon running in background (default "--headless -j bacon-ls")
				-- 	runBaconInBackgroundCommandArguments = "--headless -j bacon-ls",
				-- 	-- How many milliseconds to wait between background diagnostics check to synchronize all open files (default: 2000).
				-- 	synchronizeAllOpenFilesWaitMillis = 1500,
				-- },
				rust_analyzer = {
					settings = {
						["rust-analyzer"] = {
							checkOnSave = {
								enable = true,
							},
							diagnostics = {
								enable = true,
							},
							-- enable inlay hints for types and chains
							inlayHints = {
								typeHints = {
									enable = true,
								},
								chainingHints = {
									enable = true,
								},
							},
						},
					},
				},
			},
		},
		config = function(_, opts)
			local lspconfig = require("lspconfig")
			local util = require("lspconfig.util")

			if opts.servers.phpactor then
				opts.servers.phpactor.root_dir =
					util.root_pattern(".git", "composer.json", ".phpactor.json", ".phpactor.yml")
			end

			for server, config in pairs(opts.servers) do
				if type(config) ~= "table" then
					config = {}
				end

				config.capabilities = require("blink.cmp").get_lsp_capabilities(config.capabilities)
				lspconfig[server].setup(config)
			end
		end,
	},
	"mfussenegger/nvim-jdtls",
	{
		"mason-org/mason.nvim",
		opts = {},
	},
}
</file>

<file path="lua/plugins/lualine.lua">
return {

	{
		"nvim-lualine/lualine.nvim",
		dependencies = { "nvim-tree/nvim-web-devicons" },
		opts = {
			options = {
				icons_enabled = true,
				theme = "auto",
				component_separators = { left = "", right = "" },
				section_separators = { left = "", right = "" },
				disabled_filetypes = {
					statusline = {},
					winbar = {},
				},
				ignore_focus = {},
				always_divide_middle = true,
				always_show_tabline = false,
				globalstatus = true,
				refresh = {
					statusline = 100,
					tabline = 100,
					winbar = 100,
				},
			},
			sections = {
				lualine_a = { "mode" },
				lualine_b = { "branch" },
				lualine_c = {
					{ "filename", path = 1 }, -- 1. Add the Snippet Indicator here
					{
						function()
							-- Check if 'luasnip' is available and if a snippet is active
							if package.loaded["luasnip"] and require("luasnip").in_snippet() then
								return "⚡ SNIP" -- You can use an icon like  or 󰆐
							end
							return ""
						end,
						color = { fg = "#ff9e64", gui = "bold" }, -- Orange color for visibility
					},
				},
				lualine_x = {
					"diff",
					"diagnostics",
				},
				lualine_y = { "lsp_status" },
				lualine_z = { "location" },
			},
			inactive_sections = {
				lualine_a = {},
				lualine_b = {},
				lualine_c = { "filename" },
				lualine_x = { "location" },
				lualine_y = {},
				lualine_z = {},
			},

			inactive_winbar = {},
			extensions = {},
		},
	},
}
</file>

<file path="lua/plugins/mini.lua">
return {
	-- Mini Nvim
	{ "echasnovski/mini.nvim", version = false },
	-- Surround
	-- {
	-- 	"echasnovski/mini.surround",
	-- 	event = { "BufReadPre", "BufNewFile" },
	-- 	opts = {
	-- 		-- Add custom surroundings to be used on top of builtin ones. For more
	-- 		-- information with examples, see `:h MiniSurround.config`.
	-- 		custom_surroundings = nil,
	--
	-- 		-- Duration (in ms) of highlight when calling `MiniSurround.highlight()`
	-- 		highlight_duration = 300,
	--
	-- 		-- Module mappings. Use `''` (empty string) to disable one.
	-- 		-- INFO:
	-- 		-- saiw surround with no whitespace
	-- 		-- saw surround with whitespace
	-- 		mappings = {
	-- 			add = "sa", -- Add surrounding in Normal and Visual modes
	-- 			delete = "ds", -- Delete surrounding
	-- 			find = "sf", -- Find surrounding (to the right)
	-- 			find_left = "sF", -- Find surrounding (to the left)
	-- 			highlight = "sh", -- Highlight surrounding
	-- 			replace = "sr", -- Replace surrounding
	-- 			update_n_lines = "sn", -- Update `n_lines`
	--
	-- 			suffix_last = "l", -- Suffix to search with "prev" method
	-- 			suffix_next = "n", -- Suffix to search with "next" method
	-- 		},
	--
	-- 		-- Number of lines within which surrounding is searched
	-- 		n_lines = 20,
	--
	-- 		-- Whether to respect selection type:
	-- 		-- - Place surroundings on separate lines in linewise mode.
	-- 		-- - Place surroundings on each line in blockwise mode.
	-- 		respect_selection_type = false,
	--
	-- 		-- How to search for surrounding (first inside current line, then inside
	-- 		-- neighborhood). One of 'cover', 'cover_or_next', 'cover_or_prev',
	-- 		-- 'cover_or_nearest', 'next', 'prev', 'nearest'. For more details,
	-- 		-- see `:h MiniSurround.config`.
	-- 		search_method = "cover",
	--
	-- 		-- Whether to disable showing non-error feedback
	-- 		silent = false,
	-- 	},
	-- },
	-- Split & join
	{
		"echasnovski/mini.splitjoin",
		config = function()
			local miniSplitJoin = require("mini.splitjoin")
			miniSplitJoin.setup({
				mappings = { toggle = "" }, -- Disable default mapping
			})
			vim.keymap.set({ "n", "x" }, "sj", function()
				miniSplitJoin.join()
			end, { desc = "Join arguments" })
			vim.keymap.set({ "n", "x" }, "sk", function()
				miniSplitJoin.split()
			end, { desc = "Split arguments" })
		end,
	},
}
</file>

<file path="lua/plugins/namu.lua">
return { -- Those are the default options
	"bassamsdata/namu.nvim",
	opts = {
		namu_symbols = {
			options = {
				display = {
					icon = "icon",
					format = "tree_guides",
				},
				-- This is a preset that let's set window without really get into the hassle of tuning window options
				-- top10 meaning top 10% of the window
				row_position = "top10", -- options: "center"|"top10"|"top10_right"|"center_right"|"bottom",
			},
		},
	},
}
</file>

<file path="lua/plugins/neoscroll.lua">
return {
	"karb94/neoscroll.nvim",
	event = "VeryLazy",
	config = function()
		local neoscroll = require("neoscroll")

		neoscroll.setup({
			-- Hide cursor while scrolling creates a "floating" feel
			hide_cursor = true,
			-- Stop at end of file (prevent scrolling into the void)
			stop_eof = true,
			-- "quadratic" is a popular easing function for a natural feel
			easing = "quadratic",
			-- Default keys to hijack for smooth scrolling
			mappings = { "<C-u>", "<C-d>", "<C-b>", "<C-f>", "<C-y>", "<C-e>", "zt", "zz", "zb" },
			post_hook = function(info)
				if info == "zz" then
					vim.cmd("normal! zz") -- Center the cursor
				end
			end,
		})

		-- Define parameters for our scrolling commands
		-- "info = 'zz'" tells the post_hook to center the screen when done
		local fast_dur = 100 -- Faster animation for J/K
		local page_dur = 250 -- Standard speed for half-pages

		local modes = { "n", "v", "x" }
		local scroll_opts = { move_cursor = true, duration = fast_dur, info = {
			post_hook = "zz",
		} }

		-- 1. Fast Vertical Scroll (10 lines) + Center
		-- Syntax: scroll(lines, move_cursor, time, easing, info)
		vim.keymap.set(modes, "<C-j>", function()
			neoscroll.scroll(10, scroll_opts)
		end, { desc = "Fast scroll down & center" })

		vim.keymap.set(modes, "<C-k>", function()
			neoscroll.scroll(-10, scroll_opts)
		end, { desc = "Fast scroll up & center" })

		-- 2. Half-Page Scroll (<C-d> / <C-u>) + Center
		-- We use the helper functions which handle the 'window scroll amount' math
		vim.keymap.set(modes, "<C-d>", function()
			neoscroll.ctrl_d({
				duration = page_dur,
				info = {
					-- post_hook = "zz",
				},
			})
		end, { desc = "Scroll down half page & center" })

		vim.keymap.set(modes, "<C-u>", function()
			neoscroll.ctrl_u({
				duration = page_dur,
				info = {
					-- post_hook = "zz",
				},
			})
		end, { desc = "Scroll up half page & center" })
	end,
}
</file>

<file path="lua/plugins/render-markdown.lua">
return {
  "MeanderingProgrammer/render-markdown.nvim",
  enabled = true,
  dependencies = {
    "nvim-treesitter/nvim-treesitter",
    "nvim-tree/nvim-web-devicons",
  },
  ---@module 'render-markdown'
  -- ft = { "markdown", "norg", "rmd", "org" },
  init = function()
    -- Define colors
    local color1_bg = "#ff757f"
    local color2_bg = "#4fd6be"
    local color3_bg = "#7dcfff"
    local color4_bg = "#ff9e64"
    local color5_bg = "#7aa2f7"
    local color6_bg = "#c0caf5"
    local color_fg = "#1F2335"
    -- -- Heading background
    vim.cmd(string.format([[highlight Headline1Bg guifg=%s guibg=%s gui=bold]], color_fg, color1_bg))
    vim.cmd(string.format([[highlight Headline2Bg guifg=%s guibg=%s gui=bold]], color_fg, color2_bg))
    vim.cmd(string.format([[highlight Headline3Bg guifg=%s guibg=%s gui=bold]], color_fg, color3_bg))
    vim.cmd(string.format([[highlight Headline4Bg guifg=%s guibg=%s gui=bold]], color_fg, color4_bg))
    vim.cmd(string.format([[highlight Headline5Bg guifg=%s guibg=%s gui=bold]], color_fg, color5_bg))
    vim.cmd(string.format([[highlight Headline6Bg guifg=%s guibg=%s gui=bold]], color_fg, color6_bg))

    -- Heading fg
    -- vim.cmd(string.format([[highlight Headline1Fg guifg=%s gui=bold]], colors.color1_bg))
    -- vim.cmd(string.format([[highlight Headline2Fg guifg=%s gui=bold]], colors.color2_bg))
    -- vim.cmd(string.format([[highlight Headline3Fg guifg=%s gui=bold]], colors.color3_bg))
    -- vim.cmd(string.format([[highlight Headline4Fg guifg=%s gui=bold]], colors.color4_bg))
    -- vim.cmd(string.format([[highlight Headline5Fg guifg=%s gui=bold]], colors.color5_bg))
    -- vim.cmd(string.format([[highlight Headline6Fg guifg=%s gui=bold]], colors.color6_bg))
  end,
  opts = {
    heading = {
      sign = false,
      icons = { "󰎤 ", "󰎧 ", "󰎪 ", "󰎭 ", "󰎱 ", "󰎳 " },
      backgrounds = {
        "Headline1Bg",
        "Headline2Bg",
        "Headline3Bg",
        "Headline4Bg",
        "Headline5Bg",
        "Headline6Bg",
      },
      foregrounds = {
        "Headline1Fg",
        "Headline2Fg",
        "Headline3Fg",
        "Headline4Fg",
        "Headline5Fg",
        "Headline6Fg",
      },
    },
    code = {
      sign = false,
      width = "block",
      right_pad = 1,
    },
    bullet = {
      -- Turn on / off list bullet rendering
      enabled = true,
    },
    -- checkbox = {
    --     -- Turn on / off checkbox state rendering
    --     enabled = true,
    --     -- Determines how icons fill the available space:
    --     --  inline:  underlying text is concealed resulting in a left aligned icon
    --     --  overlay: result is left padded with spaces to hide any additional text
    --     position = "inline",
    --     unchecked = {
    --         -- Replaces '[ ]' of 'task_list_marker_unchecked'
    --         icon = "   󰄱 ",
    --         -- Highlight for the unchecked icon
    --         highlight = "RenderMarkdownUnchecked",
    --         -- Highlight for item associated with unchecked checkbox
    --         scope_highlight = nil,
    --     },
    --     checked = {
    --         -- Replaces '[x]' of 'task_list_marker_checked'
    --         icon = "   󰱒 ",
    --         -- Highlight for the checked icon
    --         highlight = "RenderMarkdownChecked",
    --         -- Highlight for item associated with checked checkbox
    --         scope_highlight = nil,
    --     },
    -- },
  },
}
</file>

<file path="lua/plugins/snacks.lua">
return {
	-- HACK: docs @ https://github.com/folke/snacks.nvim/blob/main/docs
	{
		"folke/snacks.nvim",
		priority = 1000,
		lazy = false,
		-- NOTE: Options
		opts = {
			styles = {
				input = {
					keys = {
						n_esc = { "<C-c>", { "cmp_close", "cancel" }, mode = "n", expr = true },
						i_esc = { "<C-c>", { "cmp_close", "stopinsert" }, mode = "i", expr = true },
					},
				},
			},
			-- Snacks Modules
			input = {
				enabled = true,
			},
			quickfile = {
				enabled = false,
				exclude = { "latex" },
			},
			-- HACK: read picker docs @ https://github.com/folke/snacks.nvim/blob/main/docs/picker.md
			picker = {
				enabled = true,
				matchers = {
					frecency = true,
					cwd_bonus = false,
				},
				formatters = {
					file = {
						filename_first = false,
						filename_only = false,
						icon_width = 2,
					},
				},
				layout = {
					-- presets options : "default" , "ivy" , "ivy-split" , "telescope" , "vscode", "select" , "sidebar"
					-- override picker layout in keymaps function as a param below
					preset = "telescope", -- defaults to this layout unless overidden
					cycle = false,
				},
				layouts = {
					select = {
						preview = false,
						layout = {
							backdrop = false,
							width = 0.6,
							min_width = 80,
							height = 0.4,
							min_height = 10,
							box = "vertical",
							border = "rounded",
							title = "{title}",
							title_pos = "center",
							{ win = "input", height = 1, border = "bottom" },
							{ win = "list", border = "none" },
							{ win = "preview", title = "{preview}", width = 0.6, height = 0.4, border = "top" },
						},
					},
					telescope = {
						reverse = true, -- set to false for search bar to be on top
						layout = {
							box = "horizontal",
							backdrop = false,
							width = 0.8,
							height = 0.9,
							border = "none",
							{
								box = "vertical",
								{ win = "list", title = " Results ", title_pos = "center", border = "rounded" },
								{
									win = "input",
									height = 1,
									border = "rounded",
									title = "{title} {live} {flags}",
									title_pos = "center",
								},
							},
							{
								win = "preview",
								title = "{preview:Preview}",
								width = 0.50,
								border = "rounded",
								title_pos = "center",
							},
						},
					},
					ivy = {
						layout = {
							box = "vertical",
							backdrop = false,
							width = 0,
							height = 0.4,
							position = "bottom",
							border = "top",
							title = " {title} {live} {flags}",
							title_pos = "left",
							{ win = "input", height = 1, border = "bottom" },
							{
								box = "horizontal",
								{ win = "list", border = "none" },
								{ win = "preview", title = "{preview}", width = 0.5, border = "left" },
							},
						},
					},
				},
			},
			win = {
				input = {
					keys = {
						-- to close the picker on ESC instead of going to normal mode,
						-- add the following keymap to your config
						-- ["<Esc>"] = { "close", mode = { "n", "i" } },
						["/"] = "toggle_focus",
						["<C-Down>"] = { "history_forward", mode = { "i", "n" } },
						["<C-Up>"] = { "history_back", mode = { "i", "n" } },
						["<C-c>"] = { "cancel", mode = "i" },
						["<C-w>"] = { "<c-s-w>", mode = { "i" }, expr = true, desc = "delete word" },
						["<CR>"] = { "confirm", mode = { "n", "i" } },
						["<Down>"] = { "list_down", mode = { "i", "n" } },
						["<Esc>"] = "cancel",
						["<S-CR>"] = { { "pick_win", "jump" }, mode = { "n", "i" } },
						["<S-Tab>"] = { "select_and_prev", mode = { "i", "n" } },
						["<Tab>"] = { "select_and_next", mode = { "i", "n" } },
						["<Up>"] = { "list_up", mode = { "i", "n" } },
						["<a-d>"] = { "inspect", mode = { "n", "i" } },
						["<a-f>"] = { "toggle_follow", mode = { "i", "n" } },
						["<a-h>"] = { "toggle_hidden", mode = { "i", "n" } },
						["<a-i>"] = { "toggle_ignored", mode = { "i", "n" } },
						["<a-r>"] = { "toggle_regex", mode = { "i", "n" } },
						["<a-m>"] = { "toggle_maximize", mode = { "i", "n" } },
						["<a-p>"] = { "toggle_preview", mode = { "i", "n" } },
						["<a-w>"] = { "cycle_win", mode = { "i", "n" } },
						["<c-a>"] = { "select_all", mode = { "n", "i" } },
						["<c-b>"] = { "preview_scroll_up", mode = { "i", "n" } },
						["<c-d>"] = { "list_scroll_down", mode = { "i", "n" } },
						["<c-f>"] = { "preview_scroll_down", mode = { "i", "n" } },
						["<c-g>"] = { "toggle_live", mode = { "i", "n" } },
						["<c-j>"] = { "list_down", mode = { "i", "n" } },
						["<c-k>"] = { "list_up", mode = { "i", "n" } },
						["<c-n>"] = { "list_down", mode = { "i", "n" } },
						["<c-p>"] = { "list_up", mode = { "i", "n" } },
						["<c-q>"] = { "qflist", mode = { "i", "n" } },
						["<c-s>"] = { "edit_split", mode = { "i", "n" } },
						["<c-t>"] = { "tab", mode = { "n", "i" } },
						["<c-u>"] = { "list_scroll_up", mode = { "i", "n" } },
						["<c-v>"] = { "edit_vsplit", mode = { "i", "n" } },
						["<c-r>#"] = { "insert_alt", mode = "i" },
						["<c-r>%"] = { "insert_filename", mode = "i" },
						["<c-r><c-a>"] = { "insert_cWORD", mode = "i" },
						["<c-r><c-f>"] = { "insert_file", mode = "i" },
						["<c-r><c-l>"] = { "insert_line", mode = "i" },
						["<c-r><c-p>"] = { "insert_file_full", mode = "i" },
						["<c-r><c-w>"] = { "insert_cword", mode = "i" },
						["<c-w>H"] = "layout_left",
						["<c-w>J"] = "layout_bottom",
						["<c-w>K"] = "layout_top",
						["<c-w>L"] = "layout_right",
						["?"] = "toggle_help_input",
						["G"] = "list_bottom",
						["gg"] = "list_top",
						["j"] = "list_down",
						["k"] = "list_up",
						["q"] = "cancel",
					},
				},
			},
			image = {
				enabled = true,
				doc = {
					float = true, -- show image on cursor hover
					inline = false, -- show image inline
					max_width = 50,
					max_height = 30,
					wo = {
						wrap = false,
					},
				},
				convert = {
					notify = true,
					command = "magick",
				},
				img_dirs = {
					"img",
					"images",
					"assets",
					"static",
					"public",
					"media",
					"attachments",
					"Archives/All-Vault-Images/",
					"~/Library",
					"~/Downloads",
				},
			},
			dashboard = {
				enabled = false,
				sections = {
					{ section = "header" },
					{ section = "keys", gap = 1, padding = 1 },
					{ section = "startup" },
					{
						section = "terminal",
						cmd = "chafa --format symbols ~/Desktop/Others/profiles.jpg",
						random = false,
						pane = 2,
						height = 28,
					},
				},
			},
		},
		-- NOTE: Keymaps
		keys = {
			{
				"<leader>gl",
				function()
					require("snacks").lazygit.log()
				end,
				desc = "Lazygit Logs",
			},
			{
				"<leader>rN",
				function()
					require("snacks").rename.rename_file()
				end,
				desc = "Fast Rename Current File",
			},

			-- Snacks Picker
			-- {
			-- 	"<leader>pc",
			-- 	function()
			-- 		require("snacks").picker.files({ cwd = vim.fn.stdpath("config") })
			-- 	end,
			-- 	desc = "Find Config File",
			-- },
			-- {
			-- 	"<leader>pws",
			-- 	function()
			-- 		require("snacks").picker.grep_word()
			-- 	end,
			-- 	desc = "Search Visual selection or Word",
			-- 	mode = { "n", "x" },
			-- },
			-- {
			-- 	"grr",
			-- 	function()
			-- 		Snacks.picker.lsp_references()
			-- 	end,
			-- 	nowait = true,
			-- 	desc = "References",
			-- },

			-- Git Stuff
			{
				"<leader>gbr",
				function()
					require("snacks").picker.git_branches({ layout = "select" })
				end,
				desc = "Pick and Switch Git Branches",
			},

			-- Other Utils
			{
				"<leader>vh",
				function()
					require("snacks").picker.help()
				end,
				desc = "Help Pages",
			},
		},
	},
	-- NOTE: todo comments w/ snacks
	{
		"folke/todo-comments.nvim",
		dependencies = { "nvim-lua/plenary.nvim" },
		event = { "BufReadPre", "BufNewFile" },
		optional = true,
		keys = {
			{
				"<leader>pt",
				function()
					require("snacks").picker.todo_comments()
				end,
				desc = "Todo",
			},
			{
				"<leader>pT",
				function()
					require("snacks").picker.todo_comments({ keywords = { "TODO", "FIX", "FIXME" } })
				end,
				desc = "Todo/Fix/Fixme",
			},
		},
	},
}
</file>

<file path="lua/plugins/telescope.lua">
return {
	"nvim-telescope/telescope.nvim",
	tag = "0.1.8",
	dependencies = { "nvim-lua/plenary.nvim", { "nvim-telescope/telescope-fzf-native.nvim", build = "make" } },
	config = function()
		require("telescope").setup({
			pickers = {
				help_tags = {
					theme = "ivy",
				},
				find_files = {
					hidden = true,
					no_ignore = false,
					theme = "ivy",
				},
				lsp_references = {
					theme = "ivy",
				},
				lsp_definition = {
					theme = "ivy",
				},
				lsp_implementations = {
					theme = "ivy",
				},
				lsp_document_symbols = {
					theme = "ivy",
				},
				lsp_workspace_symbols = {
					theme = "ivy",
				},
				lsp_dynamic_workspace_symbols = {
					theme = "ivy",
				},
				git_files = {
					theme = "ivy",
				},
				oldfiles = {
					theme = "ivy",
				},
				live_grep = {
					theme = "ivy",
				},
			},
		})
	end,
}
</file>

<file path="lua/plugins/theme.lua">
return {
	{
		"rebelot/kanagawa.nvim",
		priority = 1000,
		opts = {
			transparent = false, -- do not set background color
		},
		config = function()
			-- Themes
			vim.o.background = "dark" -- or "light" for light mode
			vim.cmd([[colorscheme kanagawa]])

			vim.api.nvim_set_hl(0, "IblIndent", { fg = "#414868" })
			vim.api.nvim_set_hl(0, "IblScope", { fg = "#7aa2f7" })
			-- vim.api.nvim_set_hl(0, "CursorLine", { bg = "none" })
			vim.api.nvim_set_hl(0, "CursorLineNr", { bg = "none", fg = "#7aa2f7", bold = true })
			-- vim.api.nvim_set_hl(0, "Normal", { bg = "none" })
		end,
	},
}
</file>

<file path="lua/plugins/treesitter.lua">
return {
	{
		"nvim-treesitter/nvim-treesitter",
		build = ":TSUpdate",
		config = function()
			require("nvim-treesitter.configs").setup({
				-- A list of parser names, or "all" (the listed parsers MUST always be installed)
				ensure_installed = { "c", "lua", "vim", "vimdoc", "query", "markdown", "markdown_inline", "rust" },

				-- Automatically install missing parsers when entering buffer
				-- Recommendation: set to false if you don't have `tree-sitter` CLI installed locally
				auto_install = false,

				highlight = {
					enable = true,

					-- NOTE: these are the names of the parsers and not the filetype. (for example if you want to
					-- disable highlighting for the `tex` filetype, you need to include `latex` in this list as this is
					-- the name of the parser)
					-- list of language that will be disabled
					-- disable = { "c", "rust" },

					-- Or use a function for more flexibility, e.g. to disable slow treesitter highlight for large files
					disable = function(lang, buf)
						local max_filesize = 100 * 1024 -- 100 KB
						local ok, stats = pcall(vim.loop.fs_stat, vim.api.nvim_buf_get_name(buf))
						if ok and stats and stats.size > max_filesize then
							return true
						end
					end,
					additional_vim_regex_highlighting = false,
				},
			})
		end,
	},
	-- NOTE: js,ts,jsx,tsx Auto Close Tags
	{
		"windwp/nvim-ts-autotag",
		ft = { "html", "xml", "javascript", "typescript", "javascriptreact", "typescriptreact", "svelte" },
		config = function()
			-- Independent nvim-ts-autotag setup
			require("nvim-ts-autotag").setup({
				opts = {
					enable_close = true, -- Auto-close tags
					enable_rename = true, -- Auto-rename pairs
					enable_close_on_slash = false, -- Disable auto-close on trailing `</`
				},
				per_filetype = {
					["html"] = {
						enable_close = true, -- Disable auto-closing for HTML
					},
					["typescriptreact"] = {
						enable_close = true, -- Explicitly enable auto-closing (optional, defaults to `true`)
					},
				},
			})
		end,
	},
}
</file>

<file path="lua/plugins/trouble.lua">
return {
	"folke/trouble.nvim",
	dependencies = { "nvim-tree/nvim-web-devicons", "folke/todo-comments.nvim" },
	opts = {
		focus = true,
	},
	cmd = "Trouble",
	keys = {
		{ "<leader>xx", "<cmd>Trouble diagnostics toggle<CR>", desc = "Open trouble workspace diagnostics" },
		{
			"<leader>xd",
			"<cmd>Trouble diagnostics toggle filter.buf=0<CR>",
			desc = "Open trouble document diagnostics",
		},
		{ "<leader>xq", "<cmd>Trouble quickfix toggle<CR>", desc = "Open trouble quickfix list" },
		{ "<leader>xl", "<cmd>Trouble loclist toggle<CR>", desc = "Open trouble location list" },
		{ "<leader>xt", "<cmd>Trouble todo toggle<CR>", desc = "Open todos in trouble" },
	},
}
</file>

<file path="lua/plugins/undotree.lua">
return {
  "mbbill/undotree",
  config = function()
    vim.keymap.set("n", "<leader>u", vim.cmd.UndotreeToggle)
  end,
}
</file>

<file path="lua/plugins/vim.maximizer.lua">
return {
  "szw/vim-maximizer",
  keys = {
    { "<leader>sm", "<cmd>MaximizerToggle<CR>", desc = "Maximize/minimize a split" },
  },
}
</file>

<file path="lua/snippets/go.lua">
local ls = require("luasnip")
local s = ls.snippet
local t = ls.text_node
local i = ls.insert_node
local f = ls.function_node
local fmt = require("luasnip.extras.fmt").fmt

-- Helper function to get the first letter of the struct type
-- Example: "MyStruct" -> "m"
local function get_receiver(args)
	local text = args[1][1] or ""
	if text == "" then
		return "r"
	end
	return string.sub(text, 1, 1):lower()
end

return {
	-- 1. METHOD ON STRUCT (Smart Receiver)
	-- Trigger: meth
	-- Usage: Type the struct name, and the receiver 'r' will auto-update.
	s(
		"meth",
		fmt(
			[[
    func ({receiver} *{type}) {method}({args}) {ret} {{
      {body}
    }}
    ]],
			{
				type = i(1, "Type"),
				receiver = f(get_receiver, { 1 }),
				method = i(2, "MethodName"),
				args = i(3),
				ret = i(4), -- Matches the {ret} placeholder above
				body = i(0),
			}
		)
	),

	-- 2. IF ERR != NIL (Standard)
	s("ife", {
		t("if err != nil {"),
		t({ "", "\t" }),
		t("return "),
		i(1, "nil"),
		t(", "),
		i(2, "err"), -- Simple return err
		t({ "", "}" }),
		i(0),
	}),

	-- 3. IF ERR != NIL WRAPPED (fmt.Errorf)
	-- Trigger: ifew
	s("ifew", {
		t("if err != nil {"),
		t({ "", "\t" }),
		t("return "),
		i(1, "nil"),
		t(", "),
		t('fmt.Errorf("'),
		i(2, "context"),
		t(': %w", err)'),
		t({ "", "}" }),
		i(0),
	}),

	-- 4. FOR RANGE LOOP
	-- Trigger: forr
	s(
		"forr",
		fmt(
			[[
    for {k}, {v} := range {iter} {{
      {body}
    }}
    ]],
			{
				k = i(1, "_"),
				v = i(2, "v"),
				iter = i(3, "items"),
				body = i(0),
			}
		)
	),

	-- 5. BASIC TEST FUNCTION
	-- Trigger: test
	s(
		"test",
		fmt(
			[[
    func Test{name}(t *testing.T) {{
      {body}
    }}
    ]],
			{
				name = i(1, "Name"),
				body = i(0),
			}
		)
	),

	-- 6. SUB-TEST (t.Run)
	-- Trigger: tr
	s(
		"tr",
		fmt(
			[[
    t.Run("{name}", func(t *testing.T) {{
      {body}
    }})
    ]],
			{
				name = i(1, "case"),
				body = i(0),
			}
		)
	),

	-- 7. JSON TAG (Existing)
	s("json", {
		t('`json:"'),
		i(1, "name"),
		t('"`'),
	}),

	-- 8. YAML TAG
	s("yaml", {
		t('`yaml:"'),
		i(1, "name"),
		t('"`'),
	}),
}
</file>

<file path="lua/snippets/rust.lua">
local ls = require("luasnip")
local s = ls.snippet
local t = ls.text_node
local i = ls.insert_node

return {
	-- Trigger: "p" -> println!
	s("p", {
		t('println!("'),
		i(1, "{}"),
		t('", '),
		i(2, "var"),
		t(");"),
	}),

	-- Trigger: "modtest" -> Test module boilerplate
	s("modtest", {
		t("#[cfg(test)]"),
		t({ "", "mod tests {", "\tuse super::*;", "", "\t#[test]", "\tfn " }),
		i(1, "it_works"),
		t("() {", "\t\t"),
		i(0),
		t({ "", "\t}", "}" }),
	}),
}
</file>

<file path="lua/lazy_setup.lua">
-- Bootstrap lazy.nvim
local lazypath = vim.fn.stdpath("data") .. "/lazy/lazy.nvim"
if not (vim.uv or vim.loop).fs_stat(lazypath) then
	local lazyrepo = "https://github.com/folke/lazy.nvim.git"
	local out = vim.fn.system({ "git", "clone", "--filter=blob:none", "--branch=stable", lazyrepo, lazypath })
	if vim.v.shell_error ~= 0 then
		vim.api.nvim_echo({
			{ "Failed to clone lazy.nvim:\n", "ErrorMsg" },
			{ out, "WarningMsg" },
			{ "\nPress any key to exit..." },
		}, true, {})
		vim.fn.getchar()
		os.exit(1)
	end
end
vim.opt.rtp:prepend(lazypath)

-- Make sure to setup `mapleader` and `maplocalleader` before
-- loading lazy.nvim so that mappings are correct.
-- This is also a good place to setup other settings (vim.opt)
vim.g.mapleader = " "
vim.g.maplocalleader = "\\"

-- Setup lazy.nvim
require("lazy").setup({
	spec = {
		{ import = "plugins" },
	},
	{
		checker = {
			enabled = true,
			notify = false,
		},
		change_detection = {
			notify = false,
		},
	},
})
</file>

<file path="init.lua">
require("config.core.options")
require("lazy_setup")
require("config.core.keymaps")
require("config.core.autocmds")
</file>

<file path="lazy-lock.json">
{
  "LuaSnip": { "branch": "master", "commit": "de10d8414235b0a8cabfeba60d07c24304e71f5c" },
  "arrow.nvim": { "branch": "master", "commit": "6e0f726f55f99332dd726a53effd6813786b6d49" },
  "barbecue": { "branch": "main", "commit": "cd7e7da622d68136e13721865b4d919efd6325ed" },
  "blink-cmp-copilot": { "branch": "main", "commit": "439cff78780c033aa23cf061d7315314b347e3c1" },
  "blink.cmp": { "branch": "main", "commit": "bae4bae0eedd1fa55f34b685862e94a222d5c6f8" },
  "conform.nvim": { "branch": "master", "commit": "973f3cb73887d510321653044791d7937c7ec0fa" },
  "copilot.lua": { "branch": "master", "commit": "4958fb9390f624cb389be2772e3c5e718e94d8b6" },
  "cord.nvim": { "branch": "master", "commit": "5949433e6775d89b0654f79f208da86f62a96510" },
  "fidget.nvim": { "branch": "main", "commit": "2cb5edb2dd6700a958a446b20bb2be04d318da9d" },
  "flash.nvim": { "branch": "main", "commit": "fcea7ff883235d9024dc41e638f164a450c14ca2" },
  "friendly-snippets": { "branch": "main", "commit": "572f5660cf05f8cd8834e096d7b4c921ba18e175" },
  "img-clip.nvim": { "branch": "main", "commit": "d8b6b030672f9f551a0e3526347699985a779d93" },
  "indent-blankline.nvim": { "branch": "master", "commit": "005b56001b2cb30bfa61b7986bc50657816ba4ba" },
  "kanagawa.nvim": { "branch": "master", "commit": "debe91547d7fb1eef34ce26a5106f277fbfdd109" },
  "lazy.nvim": { "branch": "main", "commit": "6c3bda4aca61a13a9c63f1c1d1b16b9d3be90d7a" },
  "lazydev.nvim": { "branch": "main", "commit": "2367a6c0a01eb9edb0464731cc0fb61ed9ab9d2c" },
  "lspkind.nvim": { "branch": "master", "commit": "d79a1c3299ad0ef94e255d045bed9fa26025dab6" },
  "lualine.nvim": { "branch": "master", "commit": "b8c23159c0161f4b89196f74ee3a6d02cdc3a955" },
  "mason.nvim": { "branch": "main", "commit": "7dc4facca9702f95353d5a1f87daf23d78e31c2a" },
  "mini.nvim": { "branch": "main", "commit": "5d938b3a078a7eeae23ba9f04f180066ab8bd9ef" },
  "mini.splitjoin": { "branch": "main", "commit": "51909e9883ab206f5a92deb9ca685317387586a4" },
  "namu.nvim": { "branch": "main", "commit": "fdebb84a9a57329a1247b725740f267d85cd59a3" },
  "neoscroll.nvim": { "branch": "master", "commit": "f957373912e88579e26fdaea4735450ff2ef5c9c" },
  "nvim-autopairs": { "branch": "master", "commit": "23320e75953ac82e559c610bec5a90d9c6dfa743" },
  "nvim-colorizer.lua": { "branch": "master", "commit": "a065833f35a3a7cc3ef137ac88b5381da2ba302e" },
  "nvim-jdtls": { "branch": "master", "commit": "4d77ff02063cf88963d5cf10683ab1fd15d072de" },
  "nvim-lspconfig": { "branch": "master", "commit": "a6dbc91d9ae373a87bcd9e3c15853e309691c39b" },
  "nvim-navic": { "branch": "master", "commit": "f887d794a0f4594882814d7780980a949200a238" },
  "nvim-tree.lua": { "branch": "master", "commit": "f0e9951778802526b14c934f7bf746e1e0ae5ed0" },
  "nvim-treesitter": { "branch": "master", "commit": "42fc28ba918343ebfd5565147a42a26580579482" },
  "nvim-ts-autotag": { "branch": "main", "commit": "a1d526af391f6aebb25a8795cbc05351ed3620b5" },
  "nvim-web-devicons": { "branch": "master", "commit": "c2599a81ecabaae07c49ff9b45dcd032a8d90f1a" },
  "plenary.nvim": { "branch": "master", "commit": "b9fd5226c2f76c951fc8ed5923d85e4de065e509" },
  "render-markdown.nvim": { "branch": "main", "commit": "e5c3c500d66e9aaf04c116cdfdb0b040d56a1521" },
  "snacks.nvim": { "branch": "main", "commit": "bc0630e43be5699bb94dadc302c0d21615421d93" },
  "telescope-fzf-native.nvim": { "branch": "main", "commit": "1f08ed60cafc8f6168b72b80be2b2ea149813e55" },
  "telescope.nvim": { "branch": "master", "commit": "a0bbec21143c7bc5f8bb02e0005fa0b982edc026" },
  "tiny-inline-diagnostic.nvim": { "branch": "main", "commit": "7dcf8542059fb15c978de845fc8665428ae13a04" },
  "todo-comments.nvim": { "branch": "main", "commit": "304a8d204ee787d2544d8bc23cd38d2f929e7cc5" },
  "trouble.nvim": { "branch": "main", "commit": "85bedb7eb7fa331a2ccbecb9202d8abba64d37b3" },
  "undotree": { "branch": "master", "commit": "28f2f54a34baff90ea6f4a735ef1813ad875c743" },
  "vim-maximizer": { "branch": "master", "commit": "2e54952fe91e140a2e69f35f22131219fcd9c5f1" },
  "which-key.nvim": { "branch": "main", "commit": "370ec46f710e058c9c1646273e6b225acf47cbed" },
  "yuck.vim": { "branch": "master", "commit": "9b5e0370f70cc30383e1dabd6c215475915fe5c3" }
}
</file>

</files>
